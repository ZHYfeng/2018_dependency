// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: DependencyManager.proto
#ifndef GRPC_DependencyManager_2eproto__INCLUDED
#define GRPC_DependencyManager_2eproto__INCLUDED

#include "DependencyManager.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
    class CompletionQueue;

    class Channel;

    class ServerCompletionQueue;

    class ServerContext;
}  // namespace grpc

namespace dra {

// The DependencyManger service definition.
    class DependencyManger final {
    public:
        static constexpr char const *service_full_name() {
            return "dra.DependencyManger";
        }

        class StubInterface {
        public:
            virtual ~StubInterface() {}

            virtual ::grpc::Status GetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                                      ::dra::DependencyInput *response) = 0;

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::DependencyInput>>
            AsyncGetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                    ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::DependencyInput>>(
                        AsyncGetDependencyInputRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::DependencyInput>>
            PrepareAsyncGetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                           ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::DependencyInput>>(
                        PrepareAsyncGetDependencyInputRaw(context, request, cq));
            }

            virtual ::grpc::Status
            GetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request, ::dra::Input *response) = 0;

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Input>>
            AsyncGetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request,
                                  ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Input>>(
                        AsyncGetInputCoverageRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Input>>
            PrepareAsyncGetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request,
                                         ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Input>>(
                        PrepareAsyncGetInputCoverageRaw(context, request, cq));
            }

            virtual ::grpc::Status
            SendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                ::dra::Empty *response) = 0;

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>
            AsyncSendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                     ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>(
                        AsyncSendDependencyInputRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>
            PrepareAsyncSendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                            ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>(
                        PrepareAsyncSendDependencyInputRaw(context, request, cq));
            }

            virtual ::grpc::Status
            SendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request, ::dra::Empty *response) = 0;

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>
            AsyncSendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request,
                                   ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>(
                        AsyncSendInputCoverageRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>
            PrepareAsyncSendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request,
                                          ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::dra::Empty>>(
                        PrepareAsyncSendInputCoverageRaw(context, request, cq));
            }

            class experimental_async_interface {
            public:
                virtual ~experimental_async_interface() {}

                virtual void GetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty *request,
                                                ::dra::DependencyInput *response,
                                                std::function<void(::grpc::Status)>) = 0;

                virtual void GetDependencyInput(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                                ::dra::DependencyInput *response,
                                                std::function<void(::grpc::Status)>) = 0;

                virtual void
                GetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty *request, ::dra::Input *response,
                                 std::function<void(::grpc::Status)>) = 0;

                virtual void GetInputCoverage(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                              ::dra::Input *response, std::function<void(::grpc::Status)>) = 0;

                virtual void SendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput *request,
                                                 ::dra::Empty *response, std::function<void(::grpc::Status)>) = 0;

                virtual void SendDependencyInput(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                                 ::dra::Empty *response, std::function<void(::grpc::Status)>) = 0;

                virtual void
                SendInputCoverage(::grpc::ClientContext *context, const ::dra::Input *request, ::dra::Empty *response,
                                  std::function<void(::grpc::Status)>) = 0;

                virtual void SendInputCoverage(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                               ::dra::Empty *response, std::function<void(::grpc::Status)>) = 0;
            };

            virtual class experimental_async_interface *experimental_async() { return nullptr; }

        private:
            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::DependencyInput> *
            AsyncGetDependencyInputRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                       ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::DependencyInput> *
            PrepareAsyncGetDependencyInputRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                              ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::Input> *
            AsyncGetInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                     ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::Input> *
            PrepareAsyncGetInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                            ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::Empty> *
            AsyncSendDependencyInputRaw(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                        ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::Empty> *
            PrepareAsyncSendDependencyInputRaw(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                               ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::Empty> *
            AsyncSendInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Input &request,
                                      ::grpc::CompletionQueue *cq) = 0;

            virtual ::grpc::ClientAsyncResponseReaderInterface<::dra::Empty> *
            PrepareAsyncSendInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Input &request,
                                             ::grpc::CompletionQueue *cq) = 0;
        };

        class Stub final : public StubInterface {
        public:
            Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel);

            ::grpc::Status GetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                              ::dra::DependencyInput *response) override;

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::DependencyInput>>
            AsyncGetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                    ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::DependencyInput>>(
                        AsyncGetDependencyInputRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::DependencyInput>>
            PrepareAsyncGetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                           ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::DependencyInput>>(
                        PrepareAsyncGetDependencyInputRaw(context, request, cq));
            }

            ::grpc::Status GetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request,
                                            ::dra::Input *response) override;

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Input>>
            AsyncGetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request,
                                  ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Input>>(
                        AsyncGetInputCoverageRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Input>>
            PrepareAsyncGetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request,
                                         ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Input>>(
                        PrepareAsyncGetInputCoverageRaw(context, request, cq));
            }

            ::grpc::Status SendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                               ::dra::Empty *response) override;

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>
            AsyncSendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                     ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>(
                        AsyncSendDependencyInputRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>
            PrepareAsyncSendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                            ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>(
                        PrepareAsyncSendDependencyInputRaw(context, request, cq));
            }

            ::grpc::Status SendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request,
                                             ::dra::Empty *response) override;

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>
            AsyncSendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request,
                                   ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>(
                        AsyncSendInputCoverageRaw(context, request, cq));
            }

            std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>
            PrepareAsyncSendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request,
                                          ::grpc::CompletionQueue *cq) {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::dra::Empty>>(
                        PrepareAsyncSendInputCoverageRaw(context, request, cq));
            }

            class experimental_async final :
                    public StubInterface::experimental_async_interface {
            public:
                void GetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty *request,
                                        ::dra::DependencyInput *response, std::function<void(::grpc::Status)>) override;

                void GetDependencyInput(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                        ::dra::DependencyInput *response, std::function<void(::grpc::Status)>) override;

                void
                GetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty *request, ::dra::Input *response,
                                 std::function<void(::grpc::Status)>) override;

                void GetInputCoverage(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                      ::dra::Input *response, std::function<void(::grpc::Status)>) override;

                void SendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput *request,
                                         ::dra::Empty *response, std::function<void(::grpc::Status)>) override;

                void SendDependencyInput(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                         ::dra::Empty *response, std::function<void(::grpc::Status)>) override;

                void
                SendInputCoverage(::grpc::ClientContext *context, const ::dra::Input *request, ::dra::Empty *response,
                                  std::function<void(::grpc::Status)>) override;

                void SendInputCoverage(::grpc::ClientContext *context, const ::grpc::ByteBuffer *request,
                                       ::dra::Empty *response, std::function<void(::grpc::Status)>) override;

            private:
                friend class Stub;

                explicit experimental_async(Stub *stub) : stub_(stub) {}

                Stub *stub() { return stub_; }

                Stub *stub_;
            };

            class experimental_async_interface *experimental_async() override { return &async_stub_; }

        private:
            std::shared_ptr<::grpc::ChannelInterface> channel_;

            class experimental_async async_stub_{this};

            ::grpc::ClientAsyncResponseReader<::dra::DependencyInput> *
            AsyncGetDependencyInputRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                       ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::DependencyInput> *
            PrepareAsyncGetDependencyInputRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                              ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::Input> *
            AsyncGetInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                     ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::Input> *
            PrepareAsyncGetInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                            ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::Empty> *
            AsyncSendDependencyInputRaw(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                        ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::Empty> *
            PrepareAsyncSendDependencyInputRaw(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                               ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::Empty> *
            AsyncSendInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Input &request,
                                      ::grpc::CompletionQueue *cq) override;

            ::grpc::ClientAsyncResponseReader<::dra::Empty> *
            PrepareAsyncSendInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Input &request,
                                             ::grpc::CompletionQueue *cq) override;

            const ::grpc::internal::RpcMethod rpcmethod_GetDependencyInput_;
            const ::grpc::internal::RpcMethod rpcmethod_GetInputCoverage_;
            const ::grpc::internal::RpcMethod rpcmethod_SendDependencyInput_;
            const ::grpc::internal::RpcMethod rpcmethod_SendInputCoverage_;
        };

        static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                                             const ::grpc::StubOptions &options = ::grpc::StubOptions());

        class Service : public ::grpc::Service {
        public:
            Service();

            virtual ~Service();

            virtual ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                                      ::dra::DependencyInput *response);

            virtual ::grpc::Status
            GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request, ::dra::Input *response);

            virtual ::grpc::Status
            SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                ::dra::Empty *response);

            virtual ::grpc::Status
            SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request, ::dra::Empty *response);
        };

        template<class BaseClass>
        class WithAsyncMethod_GetDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithAsyncMethod_GetDependencyInput() {
                ::grpc::Service::MarkMethodAsync(0);
            }

            ~WithAsyncMethod_GetDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                              ::dra::DependencyInput *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestGetDependencyInput(::grpc::ServerContext *context, ::dra::Empty *request,
                                           ::grpc::ServerAsyncResponseWriter<::dra::DependencyInput> *response,
                                           ::grpc::CompletionQueue *new_call_cq,
                                           ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class WithAsyncMethod_GetInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithAsyncMethod_GetInputCoverage() {
                ::grpc::Service::MarkMethodAsync(1);
            }

            ~WithAsyncMethod_GetInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::Input *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestGetInputCoverage(::grpc::ServerContext *context, ::dra::Empty *request,
                                         ::grpc::ServerAsyncResponseWriter<::dra::Input> *response,
                                         ::grpc::CompletionQueue *new_call_cq,
                                         ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class WithAsyncMethod_SendDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithAsyncMethod_SendDependencyInput() {
                ::grpc::Service::MarkMethodAsync(2);
            }

            ~WithAsyncMethod_SendDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                               ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestSendDependencyInput(::grpc::ServerContext *context, ::dra::DependencyInput *request,
                                            ::grpc::ServerAsyncResponseWriter<::dra::Empty> *response,
                                            ::grpc::CompletionQueue *new_call_cq,
                                            ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class WithAsyncMethod_SendInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithAsyncMethod_SendInputCoverage() {
                ::grpc::Service::MarkMethodAsync(3);
            }

            ~WithAsyncMethod_SendInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                             ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestSendInputCoverage(::grpc::ServerContext *context, ::dra::Input *request,
                                          ::grpc::ServerAsyncResponseWriter<::dra::Empty> *response,
                                          ::grpc::CompletionQueue *new_call_cq,
                                          ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        typedef WithAsyncMethod_GetDependencyInput<WithAsyncMethod_GetInputCoverage<WithAsyncMethod_SendDependencyInput<WithAsyncMethod_SendInputCoverage<Service> > > > AsyncService;

        template<class BaseClass>
        class ExperimentalWithCallbackMethod_GetDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithCallbackMethod_GetDependencyInput() {
                ::grpc::Service::experimental().MarkMethodCallback(0,
                                                                   new ::grpc::internal::CallbackUnaryHandler<::dra::Empty, ::dra::DependencyInput>(
                                                                           [this](::grpc::ServerContext *context,
                                                                                  const ::dra::Empty *request,
                                                                                  ::dra::DependencyInput *response,
                                                                                  ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                               return this->GetDependencyInput(context,
                                                                                                               request,
                                                                                                               response,
                                                                                                               controller);
                                                                           }));
            }

            ~ExperimentalWithCallbackMethod_GetDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                              ::dra::DependencyInput *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::DependencyInput *response,
                                            ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class ExperimentalWithCallbackMethod_GetInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithCallbackMethod_GetInputCoverage() {
                ::grpc::Service::experimental().MarkMethodCallback(1,
                                                                   new ::grpc::internal::CallbackUnaryHandler<::dra::Empty, ::dra::Input>(
                                                                           [this](::grpc::ServerContext *context,
                                                                                  const ::dra::Empty *request,
                                                                                  ::dra::Input *response,
                                                                                  ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                               return this->GetInputCoverage(context,
                                                                                                             request,
                                                                                                             response,
                                                                                                             controller);
                                                                           }));
            }

            ~ExperimentalWithCallbackMethod_GetInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::Input *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void
            GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request, ::dra::Input *response,
                             ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class ExperimentalWithCallbackMethod_SendDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithCallbackMethod_SendDependencyInput() {
                ::grpc::Service::experimental().MarkMethodCallback(2,
                                                                   new ::grpc::internal::CallbackUnaryHandler<::dra::DependencyInput, ::dra::Empty>(
                                                                           [this](::grpc::ServerContext *context,
                                                                                  const ::dra::DependencyInput *request,
                                                                                  ::dra::Empty *response,
                                                                                  ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                               return this->SendDependencyInput(context,
                                                                                                                request,
                                                                                                                response,
                                                                                                                controller);
                                                                           }));
            }

            ~ExperimentalWithCallbackMethod_SendDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                               ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                             ::dra::Empty *response,
                                             ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class ExperimentalWithCallbackMethod_SendInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithCallbackMethod_SendInputCoverage() {
                ::grpc::Service::experimental().MarkMethodCallback(3,
                                                                   new ::grpc::internal::CallbackUnaryHandler<::dra::Input, ::dra::Empty>(
                                                                           [this](::grpc::ServerContext *context,
                                                                                  const ::dra::Input *request,
                                                                                  ::dra::Empty *response,
                                                                                  ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                               return this->SendInputCoverage(context,
                                                                                                              request,
                                                                                                              response,
                                                                                                              controller);
                                                                           }));
            }

            ~ExperimentalWithCallbackMethod_SendInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                             ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void
            SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request, ::dra::Empty *response,
                              ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        typedef ExperimentalWithCallbackMethod_GetDependencyInput<ExperimentalWithCallbackMethod_GetInputCoverage<ExperimentalWithCallbackMethod_SendDependencyInput<ExperimentalWithCallbackMethod_SendInputCoverage<Service> > > > ExperimentalCallbackService;

        template<class BaseClass>
        class WithGenericMethod_GetDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithGenericMethod_GetDependencyInput() {
                ::grpc::Service::MarkMethodGeneric(0);
            }

            ~WithGenericMethod_GetDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                              ::dra::DependencyInput *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };

        template<class BaseClass>
        class WithGenericMethod_GetInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithGenericMethod_GetInputCoverage() {
                ::grpc::Service::MarkMethodGeneric(1);
            }

            ~WithGenericMethod_GetInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::Input *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };

        template<class BaseClass>
        class WithGenericMethod_SendDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithGenericMethod_SendDependencyInput() {
                ::grpc::Service::MarkMethodGeneric(2);
            }

            ~WithGenericMethod_SendDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                               ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };

        template<class BaseClass>
        class WithGenericMethod_SendInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithGenericMethod_SendInputCoverage() {
                ::grpc::Service::MarkMethodGeneric(3);
            }

            ~WithGenericMethod_SendInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                             ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };

        template<class BaseClass>
        class WithRawMethod_GetDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithRawMethod_GetDependencyInput() {
                ::grpc::Service::MarkMethodRaw(0);
            }

            ~WithRawMethod_GetDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                              ::dra::DependencyInput *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestGetDependencyInput(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                           ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                           ::grpc::CompletionQueue *new_call_cq,
                                           ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class WithRawMethod_GetInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithRawMethod_GetInputCoverage() {
                ::grpc::Service::MarkMethodRaw(1);
            }

            ~WithRawMethod_GetInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::Input *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestGetInputCoverage(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                         ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                         ::grpc::CompletionQueue *new_call_cq,
                                         ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class WithRawMethod_SendDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithRawMethod_SendDependencyInput() {
                ::grpc::Service::MarkMethodRaw(2);
            }

            ~WithRawMethod_SendDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                               ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestSendDependencyInput(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                            ::grpc::CompletionQueue *new_call_cq,
                                            ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class WithRawMethod_SendInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithRawMethod_SendInputCoverage() {
                ::grpc::Service::MarkMethodRaw(3);
            }

            ~WithRawMethod_SendInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                             ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            void RequestSendInputCoverage(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                                          ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                                          ::grpc::CompletionQueue *new_call_cq,
                                          ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
                ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
            }
        };

        template<class BaseClass>
        class ExperimentalWithRawCallbackMethod_GetDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithRawCallbackMethod_GetDependencyInput() {
                ::grpc::Service::experimental().MarkMethodRawCallback(0,
                                                                      new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                                                              [this](::grpc::ServerContext *context,
                                                                                     const ::grpc::ByteBuffer *request,
                                                                                     ::grpc::ByteBuffer *response,
                                                                                     ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                                  this->GetDependencyInput(context,
                                                                                                           request,
                                                                                                           response,
                                                                                                           controller);
                                                                              }));
            }

            ~ExperimentalWithRawCallbackMethod_GetDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                              ::dra::DependencyInput *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void GetDependencyInput(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
                                            ::grpc::ByteBuffer *response,
                                            ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class ExperimentalWithRawCallbackMethod_GetInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithRawCallbackMethod_GetInputCoverage() {
                ::grpc::Service::experimental().MarkMethodRawCallback(1,
                                                                      new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                                                              [this](::grpc::ServerContext *context,
                                                                                     const ::grpc::ByteBuffer *request,
                                                                                     ::grpc::ByteBuffer *response,
                                                                                     ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                                  this->GetInputCoverage(context,
                                                                                                         request,
                                                                                                         response,
                                                                                                         controller);
                                                                              }));
            }

            ~ExperimentalWithRawCallbackMethod_GetInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::Input *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void GetInputCoverage(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
                                          ::grpc::ByteBuffer *response,
                                          ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class ExperimentalWithRawCallbackMethod_SendDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithRawCallbackMethod_SendDependencyInput() {
                ::grpc::Service::experimental().MarkMethodRawCallback(2,
                                                                      new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                                                              [this](::grpc::ServerContext *context,
                                                                                     const ::grpc::ByteBuffer *request,
                                                                                     ::grpc::ByteBuffer *response,
                                                                                     ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                                  this->SendDependencyInput(context,
                                                                                                            request,
                                                                                                            response,
                                                                                                            controller);
                                                                              }));
            }

            ~ExperimentalWithRawCallbackMethod_SendDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                               ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void SendDependencyInput(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
                                             ::grpc::ByteBuffer *response,
                                             ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class ExperimentalWithRawCallbackMethod_SendInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            ExperimentalWithRawCallbackMethod_SendInputCoverage() {
                ::grpc::Service::experimental().MarkMethodRawCallback(3,
                                                                      new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                                                              [this](::grpc::ServerContext *context,
                                                                                     const ::grpc::ByteBuffer *request,
                                                                                     ::grpc::ByteBuffer *response,
                                                                                     ::grpc::experimental::ServerCallbackRpcController *controller) {
                                                                                  this->SendInputCoverage(context,
                                                                                                          request,
                                                                                                          response,
                                                                                                          controller);
                                                                              }));
            }

            ~ExperimentalWithRawCallbackMethod_SendInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable synchronous version of this method
            ::grpc::Status SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                             ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            virtual void SendInputCoverage(::grpc::ServerContext *context, const ::grpc::ByteBuffer *request,
                                           ::grpc::ByteBuffer *response,
                                           ::grpc::experimental::ServerCallbackRpcController *controller) {
                controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, ""));
            }
        };

        template<class BaseClass>
        class WithStreamedUnaryMethod_GetDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithStreamedUnaryMethod_GetDependencyInput() {
                ::grpc::Service::MarkMethodStreamed(0,
                                                    new ::grpc::internal::StreamedUnaryHandler<::dra::Empty, ::dra::DependencyInput>(
                                                            std::bind(
                                                                    &WithStreamedUnaryMethod_GetDependencyInput<BaseClass>::StreamedGetDependencyInput,
                                                                    this, std::placeholders::_1,
                                                                    std::placeholders::_2)));
            }

            ~WithStreamedUnaryMethod_GetDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable regular version of this method
            ::grpc::Status GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                              ::dra::DependencyInput *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedGetDependencyInput(::grpc::ServerContext *context,
                                                              ::grpc::ServerUnaryStreamer<::dra::Empty, ::dra::DependencyInput> *server_unary_streamer) = 0;
        };

        template<class BaseClass>
        class WithStreamedUnaryMethod_GetInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithStreamedUnaryMethod_GetInputCoverage() {
                ::grpc::Service::MarkMethodStreamed(1,
                                                    new ::grpc::internal::StreamedUnaryHandler<::dra::Empty, ::dra::Input>(
                                                            std::bind(
                                                                    &WithStreamedUnaryMethod_GetInputCoverage<BaseClass>::StreamedGetInputCoverage,
                                                                    this, std::placeholders::_1,
                                                                    std::placeholders::_2)));
            }

            ~WithStreamedUnaryMethod_GetInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable regular version of this method
            ::grpc::Status GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                            ::dra::Input *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedGetInputCoverage(::grpc::ServerContext *context,
                                                            ::grpc::ServerUnaryStreamer<::dra::Empty, ::dra::Input> *server_unary_streamer) = 0;
        };

        template<class BaseClass>
        class WithStreamedUnaryMethod_SendDependencyInput : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithStreamedUnaryMethod_SendDependencyInput() {
                ::grpc::Service::MarkMethodStreamed(2,
                                                    new ::grpc::internal::StreamedUnaryHandler<::dra::DependencyInput, ::dra::Empty>(
                                                            std::bind(
                                                                    &WithStreamedUnaryMethod_SendDependencyInput<BaseClass>::StreamedSendDependencyInput,
                                                                    this, std::placeholders::_1,
                                                                    std::placeholders::_2)));
            }

            ~WithStreamedUnaryMethod_SendDependencyInput() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable regular version of this method
            ::grpc::Status SendDependencyInput(::grpc::ServerContext *context, const ::dra::DependencyInput *request,
                                               ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedSendDependencyInput(::grpc::ServerContext *context,
                                                               ::grpc::ServerUnaryStreamer<::dra::DependencyInput, ::dra::Empty> *server_unary_streamer) = 0;
        };

        template<class BaseClass>
        class WithStreamedUnaryMethod_SendInputCoverage : public BaseClass {
        private:
            void BaseClassMustBeDerivedFromService(const Service *service) {}

        public:
            WithStreamedUnaryMethod_SendInputCoverage() {
                ::grpc::Service::MarkMethodStreamed(3,
                                                    new ::grpc::internal::StreamedUnaryHandler<::dra::Input, ::dra::Empty>(
                                                            std::bind(
                                                                    &WithStreamedUnaryMethod_SendInputCoverage<BaseClass>::StreamedSendInputCoverage,
                                                                    this, std::placeholders::_1,
                                                                    std::placeholders::_2)));
            }

            ~WithStreamedUnaryMethod_SendInputCoverage() override {
                BaseClassMustBeDerivedFromService(this);
            }

            // disable regular version of this method
            ::grpc::Status SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                             ::dra::Empty *response) override {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }

            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedSendInputCoverage(::grpc::ServerContext *context,
                                                             ::grpc::ServerUnaryStreamer<::dra::Input, ::dra::Empty> *server_unary_streamer) = 0;
        };

        typedef WithStreamedUnaryMethod_GetDependencyInput<WithStreamedUnaryMethod_GetInputCoverage<WithStreamedUnaryMethod_SendDependencyInput<WithStreamedUnaryMethod_SendInputCoverage<Service> > > > StreamedUnaryService;
        typedef Service SplitStreamedService;
        typedef WithStreamedUnaryMethod_GetDependencyInput<WithStreamedUnaryMethod_GetInputCoverage<WithStreamedUnaryMethod_SendDependencyInput<WithStreamedUnaryMethod_SendInputCoverage<Service> > > > StreamedService;
    };

}  // namespace dra


#endif  // GRPC_DependencyManager_2eproto__INCLUDED
