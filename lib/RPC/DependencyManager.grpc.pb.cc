// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: DependencyManager.proto

#include "DependencyManager.pb.h"
#include "DependencyManager.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace dra {

    static const char *DependencyManger_method_names[] = {
            "/dra.DependencyManger/GetDependencyInput",
            "/dra.DependencyManger/GetInputCoverage",
            "/dra.DependencyManger/SendDependencyInput",
            "/dra.DependencyManger/SendInputCoverage",
    };

    std::unique_ptr<DependencyManger::Stub>
    DependencyManger::NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                              const ::grpc::StubOptions &options) {
        (void) options;
        std::unique_ptr<DependencyManger::Stub> stub(new DependencyManger::Stub(channel));
        return stub;
    }

    DependencyManger::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel)
            : channel_(channel),
              rpcmethod_GetDependencyInput_(DependencyManger_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
                                            channel),
              rpcmethod_GetInputCoverage_(DependencyManger_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
                                          channel),
              rpcmethod_SendDependencyInput_(DependencyManger_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC,
                                             channel),
              rpcmethod_SendInputCoverage_(DependencyManger_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC,
                                           channel) {}

    ::grpc::Status
    DependencyManger::Stub::GetDependencyInput(::grpc::ClientContext *context, const ::dra::Empty &request,
                                               ::dra::DependencyInput *response) {
        return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetDependencyInput_, context, request,
                                                   response);
    }

    void DependencyManger::Stub::experimental_async::GetDependencyInput(::grpc::ClientContext *context,
                                                                        const ::dra::Empty *request,
                                                                        ::dra::DependencyInput *response,
                                                                        std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetDependencyInput_, context,
                                                   request, response, std::move(f));
    }

    void DependencyManger::Stub::experimental_async::GetDependencyInput(::grpc::ClientContext *context,
                                                                        const ::grpc::ByteBuffer *request,
                                                                        ::dra::DependencyInput *response,
                                                                        std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetDependencyInput_, context,
                                                   request, response, std::move(f));
    }

    ::grpc::ClientAsyncResponseReader<::dra::DependencyInput> *
    DependencyManger::Stub::AsyncGetDependencyInputRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                                       ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::DependencyInput>::Create(channel_.get(), cq,
                                                                                                  rpcmethod_GetDependencyInput_,
                                                                                                  context, request,
                                                                                                  true);
    }

    ::grpc::ClientAsyncResponseReader<::dra::DependencyInput> *
    DependencyManger::Stub::PrepareAsyncGetDependencyInputRaw(::grpc::ClientContext *context,
                                                              const ::dra::Empty &request,
                                                              ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::DependencyInput>::Create(channel_.get(), cq,
                                                                                                  rpcmethod_GetDependencyInput_,
                                                                                                  context, request,
                                                                                                  false);
    }

    ::grpc::Status DependencyManger::Stub::GetInputCoverage(::grpc::ClientContext *context, const ::dra::Empty &request,
                                                            ::dra::Input *response) {
        return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetInputCoverage_, context, request,
                                                   response);
    }

    void DependencyManger::Stub::experimental_async::GetInputCoverage(::grpc::ClientContext *context,
                                                                      const ::dra::Empty *request,
                                                                      ::dra::Input *response,
                                                                      std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetInputCoverage_, context,
                                                   request, response, std::move(f));
    }

    void DependencyManger::Stub::experimental_async::GetInputCoverage(::grpc::ClientContext *context,
                                                                      const ::grpc::ByteBuffer *request,
                                                                      ::dra::Input *response,
                                                                      std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetInputCoverage_, context,
                                                   request, response, std::move(f));
    }

    ::grpc::ClientAsyncResponseReader<::dra::Input> *
    DependencyManger::Stub::AsyncGetInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                                     ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::Input>::Create(channel_.get(), cq,
                                                                                        rpcmethod_GetInputCoverage_,
                                                                                        context, request, true);
    }

    ::grpc::ClientAsyncResponseReader<::dra::Input> *
    DependencyManger::Stub::PrepareAsyncGetInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Empty &request,
                                                            ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::Input>::Create(channel_.get(), cq,
                                                                                        rpcmethod_GetInputCoverage_,
                                                                                        context, request, false);
    }

    ::grpc::Status
    DependencyManger::Stub::SendDependencyInput(::grpc::ClientContext *context, const ::dra::DependencyInput &request,
                                                ::dra::Empty *response) {
        return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SendDependencyInput_, context, request,
                                                   response);
    }

    void DependencyManger::Stub::experimental_async::SendDependencyInput(::grpc::ClientContext *context,
                                                                         const ::dra::DependencyInput *request,
                                                                         ::dra::Empty *response,
                                                                         std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendDependencyInput_,
                                                   context, request, response, std::move(f));
    }

    void DependencyManger::Stub::experimental_async::SendDependencyInput(::grpc::ClientContext *context,
                                                                         const ::grpc::ByteBuffer *request,
                                                                         ::dra::Empty *response,
                                                                         std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendDependencyInput_,
                                                   context, request, response, std::move(f));
    }

    ::grpc::ClientAsyncResponseReader<::dra::Empty> *
    DependencyManger::Stub::AsyncSendDependencyInputRaw(::grpc::ClientContext *context,
                                                        const ::dra::DependencyInput &request,
                                                        ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::Empty>::Create(channel_.get(), cq,
                                                                                        rpcmethod_SendDependencyInput_,
                                                                                        context, request, true);
    }

    ::grpc::ClientAsyncResponseReader<::dra::Empty> *
    DependencyManger::Stub::PrepareAsyncSendDependencyInputRaw(::grpc::ClientContext *context,
                                                               const ::dra::DependencyInput &request,
                                                               ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::Empty>::Create(channel_.get(), cq,
                                                                                        rpcmethod_SendDependencyInput_,
                                                                                        context, request, false);
    }

    ::grpc::Status
    DependencyManger::Stub::SendInputCoverage(::grpc::ClientContext *context, const ::dra::Input &request,
                                              ::dra::Empty *response) {
        return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SendInputCoverage_, context, request,
                                                   response);
    }

    void DependencyManger::Stub::experimental_async::SendInputCoverage(::grpc::ClientContext *context,
                                                                       const ::dra::Input *request,
                                                                       ::dra::Empty *response,
                                                                       std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendInputCoverage_, context,
                                                   request, response, std::move(f));
    }

    void DependencyManger::Stub::experimental_async::SendInputCoverage(::grpc::ClientContext *context,
                                                                       const ::grpc::ByteBuffer *request,
                                                                       ::dra::Empty *response,
                                                                       std::function<void(::grpc::Status)> f) {
        return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SendInputCoverage_, context,
                                                   request, response, std::move(f));
    }

    ::grpc::ClientAsyncResponseReader<::dra::Empty> *
    DependencyManger::Stub::AsyncSendInputCoverageRaw(::grpc::ClientContext *context, const ::dra::Input &request,
                                                      ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::Empty>::Create(channel_.get(), cq,
                                                                                        rpcmethod_SendInputCoverage_,
                                                                                        context, request, true);
    }

    ::grpc::ClientAsyncResponseReader<::dra::Empty> *
    DependencyManger::Stub::PrepareAsyncSendInputCoverageRaw(::grpc::ClientContext *context,
                                                             const ::dra::Input &request, ::grpc::CompletionQueue *cq) {
        return ::grpc::internal::ClientAsyncResponseReaderFactory<::dra::Empty>::Create(channel_.get(), cq,
                                                                                        rpcmethod_SendInputCoverage_,
                                                                                        context, request, false);
    }

    DependencyManger::Service::Service() {
        AddMethod(new ::grpc::internal::RpcServiceMethod(
                DependencyManger_method_names[0],
                ::grpc::internal::RpcMethod::NORMAL_RPC,
                new ::grpc::internal::RpcMethodHandler<DependencyManger::Service, ::dra::Empty, ::dra::DependencyInput>(
                        std::mem_fn(&DependencyManger::Service::GetDependencyInput), this)));
        AddMethod(new ::grpc::internal::RpcServiceMethod(
                DependencyManger_method_names[1],
                ::grpc::internal::RpcMethod::NORMAL_RPC,
                new ::grpc::internal::RpcMethodHandler<DependencyManger::Service, ::dra::Empty, ::dra::Input>(
                        std::mem_fn(&DependencyManger::Service::GetInputCoverage), this)));
        AddMethod(new ::grpc::internal::RpcServiceMethod(
                DependencyManger_method_names[2],
                ::grpc::internal::RpcMethod::NORMAL_RPC,
                new ::grpc::internal::RpcMethodHandler<DependencyManger::Service, ::dra::DependencyInput, ::dra::Empty>(
                        std::mem_fn(&DependencyManger::Service::SendDependencyInput), this)));
        AddMethod(new ::grpc::internal::RpcServiceMethod(
                DependencyManger_method_names[3],
                ::grpc::internal::RpcMethod::NORMAL_RPC,
                new ::grpc::internal::RpcMethodHandler<DependencyManger::Service, ::dra::Input, ::dra::Empty>(
                        std::mem_fn(&DependencyManger::Service::SendInputCoverage), this)));
    }

    DependencyManger::Service::~Service() {
    }

    ::grpc::Status
    DependencyManger::Service::GetDependencyInput(::grpc::ServerContext *context, const ::dra::Empty *request,
                                                  ::dra::DependencyInput *response) {
        (void) context;
        (void) request;
        (void) response;
        return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }

    ::grpc::Status
    DependencyManger::Service::GetInputCoverage(::grpc::ServerContext *context, const ::dra::Empty *request,
                                                ::dra::Input *response) {
        (void) context;
        (void) request;
        (void) response;
        return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }

    ::grpc::Status DependencyManger::Service::SendDependencyInput(::grpc::ServerContext *context,
                                                                  const ::dra::DependencyInput *request,
                                                                  ::dra::Empty *response) {
        (void) context;
        (void) request;
        (void) response;
        return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }

    ::grpc::Status
    DependencyManger::Service::SendInputCoverage(::grpc::ServerContext *context, const ::dra::Input *request,
                                                 ::dra::Empty *response) {
        (void) context;
        (void) request;
        (void) response;
        return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }


}  // namespace dra

